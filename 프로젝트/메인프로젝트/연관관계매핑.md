# JPA연관관계 매핑
> JPA로 연관관계 매핑을 하다보면, 가장 많이 사용하게 되는 경우가 
> 1대N, N대1이다.(가끔 1대1도 사용한다.)  
> 여기서 보면 N대N의 경우는 없는데, 실제론 ERD 설계할때는 N대N이 필요한 경우가 있다


## N대M 매핑
 - 실제로 JPA에서는 다대다[N:M] 매핑을 할 수 있는 애노테이션 @ManyToMany 가 있다. 
 - 하지만, 실무에서는 사용하지않고, 일대다[1:N], 다대일[M:1]로 나눠서 사용한다. 

### 다대다를 사용하면 안되는 이유 
 - 사용하면 안되는 이유가 거창할 것 같지만, 생각보다 간단하다. 
 - 다대다를 사용하면 연관관계는 연결이 될수 있으나, 각각하나에 대한 연결된 정보를 알수가 없다. 
   - 즉, 비즈니스 로직상 필요한 정보들을 추가해서 넣기 어렵기 때문이다. 
 - 개다가, 컨트롤이나 성능적인 측면에서도 효율적이지 못하다.
   - 중간 테이블이 숨겨져 있어서 예상치못한 쿼리가 발생할 수 있다.

> 비즈니스 용도에는 적합하기 않은 연관관계이다. 

## [1:N], [M:1] 매핑
> 일대다, 다대일 매핑 자체를 다루는 이야기는 많으므로, 내가 헤깔리는 부분만 정리하고자 한다. 

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/192203078-7d82cb6c-b3b8-4258-8a9d-c582a4eabbb0.png" width="70%"></p>

- 내가 가장 헤깔렸던 것은 [1:N], [M:1] 매핑 사이에 끼는 테이블만 생성이 되는 API가 별도로 없다. 
  - 즉, 위 사진처럼, 가운데끼는 곳에 값을 넣을라면 주문API요청을 받거나, 커피API요청을 받을 때 생성을 해줘야된다는 것이다.
- 보통 가운데 테이블에들어가는 컬럼으로는 양쪽의 id값을 가지게되는데, 간단하게 코드로 구현해보면 아래와 같다.

```java
@NoArgsConstructor
@Getter
@Setter
@Entity
public class OrderCoffee { // homework solution 추가
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long orderCoffeeId;

    @Column(nullable = false)
    private int quantity; //비즈니스 로직상 필요한 정보, 이외에 커피 샷 size 등이 있을 수 있다.

    @ManyToOne
    @JoinColumn(name = "ORDER_ID")
    private Order order; // 주문과 매핑

    @ManyToOne
    @JoinColumn(name = "COFFEE_ID")
    private Coffee coffee; // 커피와 매핑
}
```

<br></br>

### 문제 발생
 - 위처럼 연관관계를 맺어주고, 실제로 주문`API`를 받고 DB에 저장하는 로직을 수행하면, 
 - `ORDER_ID` 과 `COFFEE_ID`이 `null`로 뜬다. 최소한, `ORDER_ID`는 `null`로 뜰 것이다.

#### 예상하는 원인 
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/192207093-cfdcdd3a-c9a4-45e8-aa24-175bb86c1946.png" width="70%"></p>

 - 매핑이 되어있다 하더라도, 서로 관계에 값을 넣어주지 않았기 때문에 발생하는 문제라고 본다.
    - 더 자세한 사항은 추후, Entity의 생명주기랑 영속성 컨텍스트를 다루면서 알아보자

<br></br>
<br></br>

## 해결법
 - 각 Order 엔티티와 OrderCoffee 엔티티에 추가해주는 메소드를 만들어 준다. 

### OrderCoffee
```java
@Entity
public class OrderCoffee {
    //.. 위 생략
    public void addOrder(Order order) { // 연관관계를 위해, 연결하는 메소드를 만든다.
        this.order = order;  
        if (!this.order.getOrderCoffees().contains(this)) {
            this.order.getOrderCoffees().add(this);
        }
    }
|}
```

### Order
```java
@Entity(name = "ORDERS")
public class Order {
    //.. 위 생략
    public void addOrderCoffee(OrderCoffee orderCoffee) {
        this.orderCoffees.add(orderCoffee);
        if (orderCoffee.getOrder() != this) {
            orderCoffee.addOrder(this); // 위에 만들어놓은 메소드를 불러온다.
        }
    }
}
```
 - 그리고, 실제 `API`요청이 들어올때, 만들어놓은 메소드를 활용하여, 서로 데이터를 가지고 있는 형태로 만들어준다. 
    - 물론 이것을 활용하는 방법은 여러가지가 있다.

#### 방법
 1. Mapper에 활용하여, Client에서 들어오는 DTO를 Order로 바꿔주는 Mapper에서, 적용하는 방식이 있고, 
 2. 나는 `MapStruct`를 사용하고 있었기때문에, 최대한 mapstruct를 활요하고자, DTO랑, Service layer부분에 서로 참조하는 로직을 추가해주었다.

<p align="center"><img src="" width="70%"></p>


### 정리 
 - 엔티티 생명주기에 대해 공부할 필요성을 느꼈다. 
 - 영속성 컨텍스트를 좀 더 깊게 파야할 필요성을 느꼈다.